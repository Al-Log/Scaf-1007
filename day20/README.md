## 📘 문제 이름
의상

- 🧩 난이도: level 2
- 🛠 사용 언어: Python
- [문제링크](https://school.programmers.co.kr/learn/courses/30/lessons/42578)

---

### 🧠 문제 설명
의상들이 담긴 2차원 배열 clothes가 주어질 때 서로 다른 옷의 조합의 수를 return 하도록 solution 함수를 작성
각 종류별로 최대 1가지 의상만 착용/의상의 일부가 겹치더라도, 다른 의상이 겹치지 않거나, 혹은 의상을 추가로 더 착용한 경우에는 서로 다른 방법으로 옷을 착용한 것으로 계산

---

### 💡 아이디어
- 옷의 이름보다는 옷의 종류가 겹치는 문제이니 종류를 기준으로 분류
- Counter 모듈과 리스트 컴프리헨션을 이용해 딕셔너리의 밸류(옷의 종류)값만 뽑아내어 개수를 구해 딕셔너리화
- 그 딕셔너리의 밸류값(각 종류별 옷 개수)를 for문으로 반복하고 1*(밸류+1)을 한다
ex/(a,b,c)와 (1,2,3)으로 만들 수 있는 조합 수=앞 묶음 개수 * 뒷 묶음 개수=3*3=9
- +1을 하는 이유는 안입는 경우를 나타냄
앞 예시에서 각 글자나 숫자도 경우로 포함 한다면 4*4=16
- 하지만 아무것도 안입는 경우는 포함하지 않기에 앞 결과에 -1
16-1(아무것도 고르지 않은 경우)=15

---

### 배운 것, 느낀 점, 아직 이해되지 않은 점 (선택)
이번에도 이해한 것을 공식으로 나타내는 과정이 제일 어려웠다

안의 값을 각각의 값으로 계산하려는 것이 아닌 입었다/안입었다로 나누어서 바로 생각해내려고 하기에는 아직 힘들다/(a,b,c)->a,b,c,없음

빠른 해결을 위해 주위나 AI의 도움을 받아보는 것도 탁월한 선택인듯 하다

---

### 다른 사람의 풀이
위 풀이를 Counter 없이 해석/
a={} #빈 딕셔너리 생성
for _,k in clothes: #clothes의 key는 무시, value를 k로 설정
    if k not in a: 
        a[t]=2 #딕셔너리 key값(옷종류)에 2(입은거+안입은거)추가
    else: #k in a일 경우
        a[t]+=1 #그 key가 있는 value값에 1추가
이 코드가 내가 풀은 풀이의 Counter부분과 동일한 역할을 수행, 이후 공식은 동일
