## 📘 문제 이름
영어 끝말잇기

- 🧩 난이도: level 2
- 🛠 사용 언어: Python
- [문제링크](https://school.programmers.co.kr/learn/courses/30/lessons/12981)

---

### 🧠 문제 설명
n명의 사람이 영어 끝말잇기를 하고 있다.
사람의 수 n과 사람들이 순서대로 말한 단어 words 가 매개변수로 주어질 때, 가장 먼저 탈락하는 사람의 번호와 그 사람이 자신의 몇 번째 차례에 탈락하는지를 구해서 return 하도록 solution 함수를 완성

---

### 💡 아이디어
- 오답이 되는 경우는 2가지, 같은 단어를 사용하거나 단어의 첫 알파벳이 전 단어의 끝 알파벳과 맞지 않을 때
- 반복문을 하면서 답을 점검할 리스트 a를 만들어주고 words의 첫번째 단어를 추가
- words[1:]를 범위로 잡은 k를 계속 a에 추가
- 거기서 count 메소드를 사용해서 나온 개수가 2개가 잡히거나, k의 첫 알파벳이 전 단어의 끝 알파벳과 맞지 않을 때 답에 넣을 값을 계산
- 탈락하는 사람의 번호는 a의 개수를 n으로 나눴을 때 나오는 나머지로 함, 만약 나머지가 없으면 마지막 사람이 틀린 경우이므로 n의 값을 그것으로 함
- 탈락한 차례는 a의 개수를 n으로 나눴을 때 나오는 몫으로 함, 만약 나머지가 존재한다면 한 차례가 넘어간뒤 중간의 사람이 틀린 경우이므로 c에 1을 더함

---

### 배운 것, 느낀 점, 아직 이해되지 않은 점 (선택)
대학교 수업에서 들으면서 배웠던 개념들을 최대한 활용하여 해낸 문제다.

무엇이 조건인지를 인지하는 것은 오래걸리지 않지만 그것을 코드로 구현해내는 과정이 아직은 어색하다

리스트와 문자열의 슬라이싱, 반복문의 원리를 이용하여 문제를 해결하였다

그런데 이런 방식은 꽤나 효율성이 나올 것 같지는 않기에 다른 풀이들도 꽤 참고해봐야겠다

---

### 다른 사람의 풀이
범위를 리스트 자체가 아닌 range(원소)의 형태로 잡아 해결한 형태
그 풀이에서 사용한 조건:
words[k][0] != words[k-1][-1] or words[k] in words[:k]
중복 경우를 count 메소드가 아닌 in을 이용하여 해결(words[k] 이전 단어들 중에 words[k]가 있는지 서치)
끝말잇기가 되지 않는 경우는 인덱스를 k로 설정하였기에 수식으로 표현이 가능