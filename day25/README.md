## 📘 문제 이름
피로도

- 🧩 난이도: level 2
- 🛠 사용 언어: Python
- [문제링크](https://school.programmers.co.kr/learn/courses/30/lessons/87946)

---

### 🧠 문제 설명
유저의 현재 피로도 k와 각 던전별 "최소 필요 피로도", "소모 피로도"가 담긴 2차원 배열 dungeons 가 매개변수로 주어질 때, 유저가 탐험할수 있는 최대 던전 수를 return 하도록 solution 함수를 완성

---

### 💡 아이디어
- 던전 탐험의 순서는 상관없기에 순서의 모든 경우를 탐색해볼 필요가 있음(완전탐색)
- 그러기 위해 모든 경우의 수를 만들어주는 permutations를 사용
- i를 dungeons를 permutaions 한 값으로 묶어주고 각 경우마다 피로도와 행동한 횟수를 판단해야 하기에 피로도와 개수를 따로 설정
- 각 경우의 수마다 반복을 돌려서 현재 피로도가 요구 피로도 보다 높다면 소모 피로도 만큼 깍고 아니면 종료
- 그 결과가 현재 저장된 최대 행동 수 보다 많다면 그것을 저장, 아니면 유지
- 모든 경우의 수를 따진 결과 도출

---

### 배운 것, 느낀 점, 아직 이해되지 않은 점 (선택)
모든 경우의 수를 전부 나눠보고 있다가 permutations의 존재를 알게 되었고 정말 편안한 풀이가 가능했다

코딩에서 제일 중요한건 효율적으로 적재적소의 모듈과 함수를 이용하는거라는 것을 다시 한번 깨닫는다

---

### 다른 사람의 풀이
DFS(깊이 우선 탐색)를 이용한 백트래킹 풀이:
dfs 함수를 따로 생성(피로도,방문횟수,던전)만약 던전의 요구 피로도가 현재 피로도보다 크고 방문하지 않았다면, 방문 표시를 해주고 dfs 함수 안의 값들을 동기화
현재 answer보다 함수 안의 방문횟수가 더 많다면 그걸로 변경
모든 경우의 수가 다 끝나면 answer 반환
